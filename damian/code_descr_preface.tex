\newpage
\section{Code Description}
\label{sec:code_descr}
This code description tries to present as much as possible useful knowledge basing on code snippets, therefore uses simplifications where it is needed and tries to give more architecture overview, features available than focusing on explanation about every possible implementation. Moreover, sometimes deliberations about lack of features or especially what could be done better can be found.

We use \texttt{CamelCase} in C++ code and Allman indentation convention unless code is strictly related to C++'s STL then we use \texttt{Snake\_Case}, this happens among others while touching C++ 20's Concepts feature.
Furthermore, \texttt{Snake\_Case} convention we use also for naming two/n-part named directories and files.

We have principles we followed in the aspect of OOP while working with \hyperref[sec:khronos]{\ref*{sec:khronos}. Khronos APIs} consistent with RAII\footnote{"Resource Acquisition Is Initialization," is a programming idiom used in C++ and other languages to manage resources such as memory, file handles, and network connections. The core idea behind RAII is that resource allocation (or acquisition) is tied to the lifespan of an object, ensuring automatic resource deallocation (or release) when the object is destroyed.} concepts. To achieve it, we were avoiding creating Vulkan or OpenXR objects in constructors of our abstraction, but remembering to set hem null pointers to then have an option to check not null and destroy Khronos's objects.

About usage of \hyperref[sec:khronos]{\ref*{sec:khronos} Khronos's APIs} we will be economical with words because as it is stated at the beginning of this chapter our thesis is oriented around the architecture than explaining the API. And in the case of Khronos's APIs it would be tremendous effort and quite useless because on the market are available position which much better exhaust the topic of Vulkan and OpenXR - for it look at the corresponded sections: \hyperref[sec:stack_vk]{\ref*{sec:stack_vk} Vulkan} and \hyperref[sec:stack_xr]{\ref*{sec:stack_xr} OpenXR}.

\subsection{Directories Structure}
The structure of directories used in the project:
\begin{verbatim}
├───.github
│   └───workflows
├───assets
│   ├───models
│   └───shaders
├───engine
│   ├───include
│   │   └───tsengine
│   │       └───ecs
│   │           └───components
│   ├───src
│   │   ├───core
│   │   ├───ecs
│   │   │   └───systems
│   │   ├───os
│   │   │   └───win32
│   │   └───vulkan_tools
│   └───tests
├───external
│   ├───glslang
│   ├───googletest
│   ├───openxr
│   ├───tinyobjloader
│   └───vulkan
└───game
    ├───components
    └───systems
\end{verbatim}
\begin{table}[h]
\caption{Structure of directories}
\end{table}

\subsection{Namespaces}
\label{sec:namespaces}
We can distinguish in the engine a few namespaces:
\begin{itemize}
    \item ts\\
    Main engine's namespace - all the staff exposed to the user is available through this namespace.
    \begin{itemize}
        \item khronos\_utils\\
            Namespace containing staff, useful while working with OpenXr and Vulkan APIs
        \item vkLoader\\
            Inside vkLoader is available loader of Vulkan.
        \item Version\\
            Namespace defined in the build system that takes form of:
\begin{lstlisting}[language=c++, caption= Definition of TS\_VER preprocessor macro (.engine/CMakeLists.txt)]
TS_VER=v${PROJECT_VERSION_MAJOR}_${PROJECT_VERSION_MINOR}_${PROJECT_VERSION_PATCH}
\end{lstlisting}
            The purpose of this macro is to prevent from breaking the API of the engine.
    \end{itemize}
\end{itemize}