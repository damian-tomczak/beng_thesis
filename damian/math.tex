\newpage

\subsection{Engine's Math Header Only Library}

\begin{lstlisting}[language=c++, caption=]
struct Vec4 final
{
    float x, y, z, w;

    constexpr Vec4() = default;
    constexpr Vec4(const float v);
    constexpr Vec4(const float x_, const float y_, const float z_, const float w_);
    [[nodiscard]] constexpr Vec4 operator*(const float scalar) const { return {x * scalar, y * scalar, z * scalar, w * scalar}; }
    [[nodiscard]] constexpr Vec4 operator+(const Vec4& rhs) const { return {x + rhs.x, y + rhs.y, z + rhs.z, w + rhs.w}; }
    constexpr Vec4& operator+=(const Vec4& rhs);
    constexpr auto operator<=>(const Vec4& other) const = default;

    bool isNan() const { return std::isnan(x) or std::isnan(y) or std::isnan(z) or std::isnan(w); }
    bool isInf() const { return std::isinf(x) or std::isinf(y) or std::isinf(z) or std::isinf(w); }
};

inline Vec4 normalize(const Vec4& vec);
\end{lstlisting}

\begin{lstlisting}[language=c++, caption=]
struct Mat2
{
    std::array<Vec2, 2> data;

    constexpr Mat2() = default;
    constexpr Mat2(
        const float x1, const float y1,
        const float x2, const float y2);

    constexpr Mat2(const float value);

    Vec2& operator[](const size_t index);
    const Vec2& operator[](const size_t index) const;
};

inline constexpr Mat2 operator*(const Mat2& lhs, const Mat2& rhs);
inline constexpr Mat2 transpose(const Mat2& mat);
inline Mat2 inverse(const Mat2& mat);
inline std::string to_string(const Mat2& mat);
\end{lstlisting}

\begin{lstlisting}[language=c++, caption=]
struct Mat3
{
    std::array<Vec3, 3> data;

    constexpr Mat3() = default;
    constexpr Mat3(
        const float x1, const float y1, const float z1,
        const float x2, const float y2, const float z2,
        const float x3, const float y3, const float z3);

    constexpr Mat3(const float value);
    constexpr Mat3(const Quat& quat);

    Vec3& operator[](const size_t index);
    const Vec3& operator[](const size_t index) const;
};

inline constexpr Mat3 operator*(const Mat3& lhs, const Mat3& rhs);
inline constexpr Mat3 transpose(const Mat3& mat);
inline constexpr Mat3 translate(const Mat3& matrix, Vec2 translation);
inline Mat3 inverse(const Mat3& mat);
inline std::string to_string(const Mat3& mat);
\end{lstlisting}

\begin{lstlisting}[language=c++, caption=]
struct Mat4
{
    std::array<Vec4, 4> data;

    constexpr Mat4() = default;
    constexpr Mat4(
        const float x1, const float y1, const float z1, const float w1,
        const float x2, const float y2, const float z2, const float w2,
        const float x3, const float y3, const float z3, const float w3,
        const float x4, const float y4, const float z4, const float w4);

    constexpr Mat4(const float v);
    constexpr Mat4(const Quat& quat);

    Vec4& operator[](const size_t index);
    const Vec4& operator[](const size_t index) const;
};

inline constexpr Mat4 operator*(const Mat4& lhs, const Mat4& rhs);
inline constexpr Mat4 transpose(const Mat4& mat);
inline constexpr Mat4 translate(const Mat4& matrix, const Vec3& translation);
inline constexpr Mat4 scale(const Mat4& matrix, const Vec3& scaleVec);
inline std::string to_string(const Mat4 mat);
\end{lstlisting}

\begin{lstlisting}[language=c++, caption=]
struct Quat
{
    float w, x, y, z;
};
\end{lstlisting}

\begin{lstlisting}[language=c++, caption=]
inline Vec4 lerp(const Vec4 start, const Vec4 end, const float t);

template<typename T>
inline auto radians(T degrees)
{
    constexpr auto factor = std::numbers::pi_v<T> / 180;
    return degrees * factor;
}
\end{lstlisting}
