\newpage
\subsection{Engine Core}
\label{sec:engine_core}
\hspace{\parindent} When saying about TSEngine Core, we distinguish public and private part. The first visible for a game and the latter unavailable for a game.
\subsubsection{Public TSEngine Core}
\label{sec:engine_class}
\hspace{\parindent} Every game must be derived from \texttt{Engine} class declared inside \texttt{core.h}. It contains four methods, which names explain themselves. We have chosen in our opinion an interesting approach during designing this class as it doesn't contain any members, it is helpful among others for not breaking ABI, and every action as initialization (\texttt{init} function) has to be consciously chosen. Besides of it, \texttt{Engine} class uses default constructor and copy and move operations are not allowed (however we could use here \hyperref[sec:utils]{\ref*{sec:utils}} Utils) header already containing macros for that, but we wanted to keep the headers across the whole project as lightweight as possible.\\
\begin{lstlisting}[language=c++, caption=Engine class (./engine/include/tsengine/core.h)]
class Engine
{
public:
    Engine() = default;

    Engine(const Engine&) = delete;
    Engine& operator=(Engine&) = delete;
    Engine(const Engine&&) = delete;
    Engine& operator=(Engine&&) = delete;

    virtual bool init(const char*& gameName, unsigned& width, unsigned& height);
    virtual void loadLvL() = 0;
    virtual bool tick(const float dt) = 0;
    virtual void close();
};
\end{lstlisting}

Preferable way to start the engine is to call \texttt{TS\_MAIN} macro with the game class that is derived from \texttt{Engine} class. 
\begin{lstlisting}[language=c++, caption=Start of the example game (./game/game.cpp)]
TS_MAIN(gameClass)
\end{lstlisting}
But keep it in mind that \texttt{TS\_MAIN} macro is just a simple wrapper around \texttt{main} function that creates an instance of the class provided as the argument to the macro, then the pointer to it is passed to \texttt{run} function, and all of this inside try-catch exception block.
\begin{lstlisting}[language=c++, caption=\texttt{TS\_MAIN} definition (./engine/include/tsengine/core.h)]
#define TS_MAIN(gameClass)                        \
    int main()                                    \
    {                                             \
        try                                       \
        {                                         \
            auto result = ts::run(new gameClass); \
            if (result != ts::TS_SUCCESS)         \
            {                                     \
                return result;                    \
            }                                     \
        }                                         \
        catch (const std::exception& e)           \
        {                                         \
            std::cerr << e.what() << "\n";        \
            return EXIT_FAILURE;                  \
        }                                         \
                                                  \
        return EXIT_SUCCESS;                      \
    }
\end{lstlisting}

\label{sec:run_fun}
Let's take a look at the heart of the engine's namely, run function, declared inside \texttt{core.h} alongside with \hyperref[sec:engine_class]{\texttt{Engine} class declaration}.
\begin{lstlisting}[language=c++, caption=Run function (./engine/include/tsengine/core.h)]
int run(Engine* const engine);
\end{lstlisting}
For simplification-wise in this code snippet we will avoid discussion about the main loop that is the part of \texttt{run} function, but we will focus on it in the \hyperref[main_loop]{next code snippet}.
\begin{lstlisting}[language=c++, caption=Engine's run function (./engine/src/core/core.cpp)]
int run(Engine* const game) try
{
    std::lock_guard<std::mutex> _{engineInit};

    if (!game)
    {
        TS_ERR("Game pointer is invalid");
    }

    if (isAlreadyInitiated)
    {
        TS_ERR("Game is already initialized");
    }
    isAlreadyInitiated = true;

#ifdef TESTER_ADAPTER
    const auto testerAdapter = dynamic_cast<TesterEngine*>(game);
    bool isRenderingStarted{};
#endif

    unsigned width{1280}, height{720};
    const char* gameName = nullptr;
    if (!game->init(gameName, width, height))
    {
        TS_ERR("Game initialization unsuccessful");
    }

    if (gameName == nullptr)
    {
        gameName = defaultGameName.data();
        TS_WARN(("Game name wasn't set! Default game name selected: "s + gameName).c_str());
    }

    if (!std::filesystem::is_directory("assets"))
    {
        TS_ERR("Assets can not be found");
    }

    compileShaders("assets/shaders");

    auto player = gReg.createEntity();
    player.setTag("player");
    player.addComponent<ts::TransformComponent>();
    player.addComponent<ts::RigidBodyComponent>(7.f);
    
    auto grid = gReg.createEntity();
    grid.setTag("grid");
    grid.addComponent<ts::RendererComponent<PipelineType::GRID>>();

    // TODO: try to delay it
    game->loadLvL();

    Context ctx{gameName};
    ctx.createOpenXrContext().createVulkanContext();

    gReg.addSystem<AssetStore>();
    gReg.addSystem<MovementSystem>();
    gReg.addSystem<RenderSystem>(ctx.getUniformBufferOffsetAlignment());

    gReg.update();

    AssetStore::Models::load();

    auto window = Window::createWindowInstance(gameName, width, height);
    MirrorView mirrorView{ctx, window};
    mirrorView.createSurface();
    ctx.createVkDevice(mirrorView.getSurface());
    Headset headset{ctx};
    headset.init();
    Controllers controllers(ctx.getXrInstance(), headset.getXrSession());
    controllers.setupControllers();

    Renderer renderer{ctx, headset};
    renderer.createRenderer();
    mirrorView.connect(&headset, &renderer);

    TS_LOG("tsengine initialization completed successfully");

    window->show();
    [Main Loop]

    game->close();
    ctx.sync();
    isAlreadyInitiated = false;

    return EXIT_SUCCESS;
}
TS_CATCH_FALLBACK_WITH_CLEANER(runCleaner)
\end{lstlisting}

\label{main_loop}
\begin{lstlisting}[language=c++, caption=Engine main loop (./engine/src/core/core.cpp)]
    auto loop = true;
    auto previousTime = std::chrono::high_resolution_clock::now();
    auto startTime = std::chrono::steady_clock::now();
    // TODO: firstly render to the window then copy to the headset
    while (loop)
    {
        const auto nowTime = std::chrono::high_resolution_clock::now();
        const long long elapsedNanoseconds =
            std::chrono::duration_cast<std::chrono::nanoseconds>(nowTime - previousTime).count();
        static constexpr auto nanosecondsPerSecond = 1e9f;
        const auto dt = static_cast<float>(elapsedNanoseconds) / nanosecondsPerSecond;
        previousTime = nowTime;

#ifdef TESTER_ADAPTER 
        if ((testerAdapter != nullptr) && isRenderingStarted)
        {
            if (std::chrono::steady_clock::now() >= (startTime + testerAdapter->renderingDuration))
            {
                loop = false;
            }
        }
#endif

        if ((!game->tick(dt)) || headset.isExitRequested())
        {
            loop = false;
        }

        auto message = window->peekMessage();
        if (message == Window::Message::QUIT)
        {
            loop = false;
        }
        else if (message == Window::Message::RESIZE)
        {
            mirrorView.onWindowResize();
        }
        window->dispatchMessage();

        gReg.update();

        uint32_t swapchainImageIndex;
        const auto frameResult = headset.beginFrame(swapchainImageIndex);
        if (frameResult == Headset::BeginFrameResult::RENDER_FULLY)
        {
#ifdef TESTER_ADAPTER
            if (!isRenderingStarted)
            {
                isRenderingStarted = true;
            }
#endif

            controllers.sync(headset.getXrSpace(), headset.getXrFrameState().predictedDisplayTime);
            gReg.getSystem<MovementSystem>().update(dt, controllers);

            renderer.render(swapchainImageIndex);
            const auto mirrorResult = mirrorView.render(swapchainImageIndex);

            const auto isMirrorViewVisible = (mirrorResult == MirrorView::RenderResult::VISIBLE);
            renderer.submit(isMirrorViewVisible);

            if (isMirrorViewVisible)
            {
                mirrorView.present();
            }
        }

        if ((frameResult == Headset::BeginFrameResult::RENDER_FULLY) ||
            (frameResult == Headset::BeginFrameResult::RENDER_SKIP_PARTIALLY))
        {
            headset.endFrame(frameResult == Headset::BeginFrameResult::RENDER_SKIP_PARTIALLY);
        }
    }
\end{lstlisting}

\newpage
\subsubsection{Private TSEngine Core}
\label{sec:window}
\hspace{\parindent} The only private part of TSEngine core that is not simultaneously the part of renderer and headset abstraction (read \hyperref[sec:core_abstr]{\ref*{sec:core_abstr} TSEngine Core Abstraction}) is \texttt{Window} class that is an interface to be implemented by \hyperref[sec:os]{\ref*{sec:os} Operating System Specific}.

As the \texttt{Window} class is strongly based on operating system as it is the layer of abstraction on the system's window, you may be interested in of development on other platforms for its more information can be found in \hyperref[sec:build_os]{\ref*{sec:build_os} Building Operating System Specific}.
\texttt{Window} class contains common window members which are width and height of a window and the name of it. Abstract methods: \texttt{createWindow}, \texttt{show}, \texttt{peekMessage}, \texttt{dispatchMessage}. \texttt{Message} enumeration containing handled actions sent by a windows server. 
\begin{lstlisting}[language=c++, caption=Engine window interface (./engine/src/core/window.h)]
class Window
{
    TS_NOT_COPYABLE_AND_MOVEABLE(Window);

public:
    Window(const std::string_view windowName, const size_t width, const size_t height) :
        mWindowName{windowName.data() + " powered by tsengine"s}, mWidth{width}, mHeight{height}
    {}
    virtual ~Window();
    enum class Message
    {
#ifdef _WIN32
        RESIZE = WM_USER + 1,
#else
        RESIZE,
#error not implemented
#endif // _WIN32
        QUIT
    };

    virtual void createWindow() = 0;
    virtual void show() = 0;
    virtual Message peekMessage() = 0;
    virtual void dispatchMessage() = 0;

    static std::shared_ptr<Window> createWindowInstance(const std::string_view windowName, const size_t width, const size_t height);

    [[nodiscard]] size_t getWidth() const { return mWidth; }
    [[nodiscard]] size_t getHeight() const { return mHeight;}

protected:
    const size_t mWidth;
    const size_t mHeight;
    const std::string mWindowName;
};
\end{lstlisting}
The most important however is static \texttt{createWindowInstance} function that chooses and creates appropriate window based on the system in use.
\begin{lstlisting}[language=c++, caption=\texttt{createWindowInstance} (./engine/src/core/window.cpp)]
std::shared_ptr<Window> Window::createWindowInstance(const std::string_view windowName, const size_t width, const size_t height)
{
    if (isWindowAlreadyCreated)
    {
        TS_ERR("Window is already created");
    }

    std::shared_ptr<Window> window;

#ifdef _WIN32
    window = std::make_shared<Win32Window>(windowName, width, height);
#else
    #error "not implemented"
#endif // _WIN32

    window->createWindow();

    isWindowAlreadyCreated = true;

    return window;
}
\end{lstlisting}