\subsubsection{Renderer}
\label{sec:renderer}
\hspace{\parindent} We can distinguish the front-end of the renderer being the part of ECS - \hyperref[sec:renderer_system]{\ref*{sec:renderer_system}. ECS Renderer System}, but also back-end in classes:
\begin{itemize}
    \item \texttt{DataBuffer}\\
    It encapsulates Vulkan buffer handling, abstracting details such as buffer creation, memory management, and data transfer.
    \item \texttt{ImageBuffer}\\
    It is designed for encapsulation of the creation and management of Vulkan images, device memory allocations, and image views,
    \item \texttt{Pipeline}\\
    This class encompass the complexity of Vulkan many different stages and settings, from shader stages to fixed-function state like blending, depth testing, providing a more streamlined interface for setting up and using these pipelines in rendering operations. 
    \item \texttt{RenderTarget}
    It is designed to encapsulate the concept of a render target in Vulkan. It manages the creation and lifecycle of a framebuffer and associated image views, which are fundamental to rendering operations. The framebuffer combines color and depth/stencil attachments, which are used during a render pass. 
    \item \texttt{RendererProcess}
    It manages uniform data for objects and lights, handles synchronization primitives, and maintains various Vulkan objects essential for rendering operations.
    \item \texttt{Renderer}
    Comprehensive component that manages various aspects of the rendering pipeline in a Vulkan environment that plays a role of back-end of the renderer. It orchestrates render processes, manages Vulkan resources like command pools and descriptor pools, and handles different pipelines for rendering. The class's structure emphasizes controlled resource management, synchronization, and the ability to handle multiple frames in flight, which are key elements in high-performance graphics applications.
\end{itemize}